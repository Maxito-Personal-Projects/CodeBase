#version 440 core

out vec4 FragColor;

in vec3 Normal;
in vec3 UVs;
in vec3 fragPos;

float rand(vec2 n) 
{ 
	return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453);
}

vec2 Hash(vec2 c)
{
    //Non Correlated coords
	float x = fract(sin(dot(vec2(float(c.x),float(c.y)) ,vec2(12.9898,78.233))) * 43758.5453);
    float y = fract(sin(dot(c+0.5 ,vec2(12.9898,78.233))) * 43758.5453);
    
    //returning the value converted from range [0,1.0] to [-1.0,1.0]
	return vec2(2.0*x-1.0,2.0*y-1.0);
}

float noise(vec2 uv, float size)
{
    vec2 tile = floor(uv*size);    
    vec2 tile_right = vec2(tile.x+1.0,tile.y);
    vec2 tile_up = vec2(tile.x,tile.y+1.0);
    vec2 tile_diag = vec2(tile.x+1.0,tile.y+1.0);

    float tileColor_1 = rand(tile);
    float tileColor_2 = rand(tile_right);
    float tileColor_3 = rand(tile_up);
    float tileColor_4 = rand(tile_diag);
    
    float mixFactor_x=smoothstep(0.0,1.0,fract(uv.x*size));
    
    float mix_1=mix(tileColor_1,tileColor_2,mixFactor_x);
	float mix_2=mix(tileColor_3,tileColor_4,mixFactor_x);
    
    float mixFactor_y = smoothstep(0.0,1.0,fract(uv.y*size));

    float finalMix=mix(mix_1,mix_2,mixFactor_y);
    
    return finalMix;
  
    return tileColor_1;
}

float Noise(vec2 test, float size)
{
    //Converting decimals to integers [0,0,0,.....2,2,2,....,9,9,9]
	vec2 uv =test * size;
    vec2 tile = floor(uv);
    
    //Bottom Left Corner
    vec2 botLeft = tile;						//Tile Coords
    vec2 botLeftG = Hash(botLeft);				//Setting Random Gradient 
    vec2 offsetBL = uv - botLeft;				//Distance vector from coords to Corner (Now yes :D)
    float dotBL=dot(botLeftG,offsetBL);			//Dot between distance and Corner
    
    //Bottom Right Corner
    vec2 botRight = tile+vec2(1.0,0.0);
    vec2 botRightG = Hash(botRight);
    vec2 offsetBR = uv - botRight;
    float dotBR=dot(botRightG,offsetBR);
    
    //Top Left Corner
    vec2 topLeft = tile+vec2(0.0,1.0);
    vec2 topLeftG = Hash(topLeft);
    vec2 offsetTL = uv - topLeft;
    float dotTL=dot(topLeftG,offsetTL);
    
    //Top Left Corner
    vec2 topRight = tile+vec2(1.0,1.0);
    vec2 topRightG = Hash(topRight);
    vec2 offsetTR = uv - topRight;
    float dotTR=dot(topRightG,offsetTR);
    
    
    float mixFactor_x=smoothstep(0.0,1.0,fract(uv.x)); //mix factor depending on the x coords 
    float mixFactor_y=smoothstep(0.0,1.0,fract(uv.y)); //mix factor depending on the y coords 

    
    float RLBR = mix(dotBL,dotBR,mixFactor_x);
    float TLTR = mix(dotTL,dotTR,mixFactor_x);
    
    float total = mix(RLBR,TLTR,mixFactor_y);

    return (total+1.0)*0.5;
}

float mixColor(vec2 uv,float size)
{
    float col =0.0;
    float a =0.5;
    float f=1.0;
    
   	for(int i=0; i<5;i++)
   	{
    	col += a*Noise(f*(uv), size);
        a*=0.5;
        f*=2.0;
    }
    
	return col;
}

vec3 Grass(vec2 pos)
{
	vec3 color = vec3(0.0);
	
	float rand_1 = mixColor(pos,200.0);
	vec3 col1 = vec3(0.0,rand_1,0.0);
    vec3 col2 = vec3((1.0-rand_1),(1.0-rand_1)*0.5,0.0);
	color = mix(col1,col2,(1.0-rand_1)*0.9);
	
	return color;
}

vec3 Rock(vec2 pos)
{
	vec3 color = vec3(0.0);
	
	float rand_1 = mixColor(pos,50.0);
	vec3 col3 = vec3(rand_1,rand_1,rand_1);
    vec3 col4 = vec3(rand_1,rand_1*0.8,rand_1);
	color = mix(col3,col4,(1.0-rand_1)*0.9);
	
	return color;
}

vec3 Beach(vec2 pos)
{
	vec3 color = vec3(0.0);
	
	float rand_1 = mixColor(pos,50.0);
	vec3 col3 = vec3(rand_1,rand_1,0.0);
    vec3 col4 = vec3(1.0,1.0,1.0);
	color = mix(col3,col4,(1.0-rand_1)*0.9);
	
	return color;
}

vec3 Snow(vec2 pos)
{
	vec3 color = vec3(0.0);
	
	float rand_1 = mixColor(pos,200.0);
	vec3 col3 = vec3(rand_1,rand_1,rand_1);
    vec3 col4 = vec3(1.0,1.0,1.0);
	color = mix(col3,col4,(1.0-rand_1));
	
	return color;
}

void main()
{
	vec3 vecColor = Grass(UVs.xy);
	vec3 norm = normalize(Normal);
	
	vec3 blending = abs( norm );
	blending = normalize(max(blending, 0.00001));
	// Force weights to sum to 1.0
	float b = (blending.x + blending.y + blending.z);
	blending /= vec3(b, b, b);
	
	vec3 xaxis;
	vec3 yaxis;
	vec3 zaxis;
	
	float MapPos_FS_in = fragPos.y/75.0;
	vec2 uvCoords = UVs.xy;
	
	if(MapPos_FS_in<=0.1)
	{
		xaxis = Rock(uvCoords);
		yaxis = Beach(uvCoords);
		zaxis = xaxis;
	}
	else if(MapPos_FS_in>0.1 && MapPos_FS_in<0.2)
	{
		float mixFactor = (0.2-MapPos_FS_in)*10.0;
		xaxis = Rock(uvCoords);
		yaxis = mix(Beach(uvCoords),Grass(uvCoords),1.-mixFactor);
		zaxis = xaxis;
	}
	else if(MapPos_FS_in>0.2 && MapPos_FS_in<0.4)
	{
		xaxis = Rock(uvCoords);
		yaxis = Grass(uvCoords);
		zaxis = xaxis;
	}
	else if(MapPos_FS_in>0.4 && MapPos_FS_in<=0.6)
	{
		float mixFactor = (0.6-MapPos_FS_in)/0.2;
		xaxis = Rock(uvCoords);
		yaxis = mix(Grass(uvCoords),Snow(uvCoords),1.-mixFactor);
		zaxis = xaxis;
	}
	else
	{
		xaxis = Rock(uvCoords);
		yaxis = Snow(uvCoords);
		zaxis = xaxis;
	}
	
	vecColor = xaxis * blending.x + yaxis * blending.y + zaxis * blending.z;

    FragColor = vec4(vecColor,1.0);
} 