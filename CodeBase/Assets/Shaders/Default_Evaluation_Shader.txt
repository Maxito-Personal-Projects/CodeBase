#version 410 core
layout(quads, equal_spacing, ccw) in;

uniform mat4 View;
uniform mat4 Projection;
uniform float maxHeight;
uniform float seed;
uniform int gridSize;

in vec3 WorldPos_ES_in[];
in vec3 Normal_ES_in[];
in vec3 Color_ES_in[];

out vec3 WorldPos_FS_in;
out vec3 Normal_FS_in;
out vec3 Color_FS_in;

uniform float delta;

vec3 interpolate3D(vec3 v0, vec3 v1, vec3 v2,vec3 v3)
{
    return vec3(gl_TessCoord.x) * v0 + vec3(gl_TessCoord.y) * v1 + vec3(gl_TessCoord.z) * v2;
}

float rand(vec2 n) 
{ 
    return fract(sin(dot(n, vec2(12.9898, 4.1414))) * 43758.5453+seed);
}

float noise(vec2 vertexCoords)
{	
    vec2 tile = vec2(vertexCoords);
    vec2 tileMax = floor(tile);
    
    vec2 tile_right = vec2(tileMax.x+1.0,tileMax.y);
    vec2 tile_up = vec2(tileMax.x,tileMax.y+1.0);
    vec2 tile_diag = vec2(tileMax.x+1.0,tileMax.y+1.0);

    float tileColor_1 = rand(tileMax);
    float tileColor_2 = rand(tile_right);
    float tileColor_3 = rand(tile_up);
    float tileColor_4 = rand(tile_diag);
    
    float mixFactor_x=smoothstep(0.0,1.0,fract(vertexCoords).x);
    
    float mix_1=mix(tileColor_1,tileColor_2,mixFactor_x);
    float mix_2=mix(tileColor_3,tileColor_4,mixFactor_x);
    
    float mixFactor_y = smoothstep(0.0,1.0,fract(vertexCoords).y);

    float finalMix=mix(mix_1,mix_2,mixFactor_y);
    
    return finalMix;
}

float BrownianNoise(float x, float y)
{
	int pX = gl_PrimitiveID/gridSize;
	int pY = gl_PrimitiveID%gridSize;
	vec2 patchCoords = vec2(pX,pY);
    float height = 0.0;
    float a =0.5;
    float f=1.0;
	vec2 coords = vec2(x,y)+patchCoords.yx;
    
    for(int i=0; i<8;i++)
    {
        height += a*noise(f*coords);
        a*=0.5;
        f*=2.0;
    }
    
    return height;
}

//      z0 
//       |     
//z1 --  M -- z2
//       |     
//      z3 

vec3 GetVertex(float deltaX, float deltaY)
{
	//float u = gl_TessCoord.x+deltaX;
	//float omu = 1 - u; // one minus "u"
	//float v = gl_TessCoord.y+deltaY;
	//float omv = 1 - v; // one minus "v"
	
	vec3 p1 = mix(WorldPos_ES_in[0], WorldPos_ES_in[1], gl_TessCoord.x+deltaX);
	vec3 p2 = mix(WorldPos_ES_in[3], WorldPos_ES_in[2], gl_TessCoord.x+deltaX);
	
	return mix(p1, p2, gl_TessCoord.y+deltaY);
	
	//return omu * omv * WorldPos_ES_in[0] + u * omv * WorldPos_ES_in[1] +
	//u * v * WorldPos_ES_in[2] + omu * v * WorldPos_ES_in[3];
}

vec3 GetVertexNormal()
{
	vec3 ret=vec3(0.0);
	
	// vec3 z0 = GetVertex(0.0,delta);
	// z0.y = BrownianNoise(gl_TessCoord.x,gl_TessCoord.y+delta)*maxHeight;
	
	// vec3 z1 = GetVertex(-delta,0.0);
	// z1.y = BrownianNoise(gl_TessCoord.x-delta,gl_TessCoord.y)*maxHeight;
	
	// vec3 z2 = GetVertex(delta,0.0);
	// z1.y = BrownianNoise(gl_TessCoord.x+delta,gl_TessCoord.y)*maxHeight;
	
	// vec3 z3 = GetVertex(0.0,-delta);
	// z3.y = BrownianNoise(gl_TessCoord.x,gl_TessCoord.y-delta)*maxHeight;
	
	// vec3 A = z3-z0;
	// vec3 B = z2-z1;
	
	// ret = normalize(cross(A,B));
	
	float tl = BrownianNoise(gl_TessCoord.x-delta,gl_TessCoord.y+delta);
	float l = BrownianNoise(gl_TessCoord.x-delta,gl_TessCoord.y);
	float bl = BrownianNoise(gl_TessCoord.x-delta,gl_TessCoord.y-delta);
	float t = BrownianNoise(gl_TessCoord.x,gl_TessCoord.y+delta);
	float b = BrownianNoise(gl_TessCoord.x,gl_TessCoord.y-delta);
	float tr = BrownianNoise(gl_TessCoord.x+delta,gl_TessCoord.y+delta);
	float r = BrownianNoise(gl_TessCoord.x+delta,gl_TessCoord.y);
	float br = BrownianNoise(gl_TessCoord.x+delta,gl_TessCoord.y-delta);
	
	// sobel filter
	float dX = (tl + 2.0 * l + bl) - (tr + 2.0 * r + br);
	float dY = (bl + 2.0 * b + br) - (tl + 2.0 * t + tr);
	float dZ = 1.0/maxHeight;
	
	// vec3 vertical = vec3(0.0,z3.y-z0.y/maxHeight,2.0);
	// vec3 horizontal = vec3(2.0,z2.y-z1.y/maxHeight,0.0);
	
	ret = normalize(vec3(dX,dZ,dY));
	return ret;
}

void main()
{		
	WorldPos_FS_in = GetVertex(0.0,0.0);
	
    Normal_FS_in = GetVertexNormal();
	float height = BrownianNoise(gl_TessCoord.x,gl_TessCoord.y);
		
	WorldPos_FS_in.y = height*maxHeight;
	
	Color_FS_in = vec3(0.5);
	
	if(height <=0.3)
	{
		Color_FS_in = vec3(0.25,0.88,0.82);
	}
	else if(height > 0.3 && height <= 0.4)
	{
		Color_FS_in = vec3(0.94,0.81,0.42);
	}
	else if(height > 0.4 && height <= 0.6)
	{
		Color_FS_in = vec3(0.49,0.78,0.31);
	}
	else if(height >0.6 && height <= 0.8)
	{
		Color_FS_in = vec3(0.72,0.69,0.61);
	}
	else
	{
		Color_FS_in = vec3(1.0);
	}
		
	gl_Position = Projection * View * vec4(WorldPos_FS_in, 1.0);
}